// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: WhoopsMsg.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum HeadType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case loginRequest // = 0
    case loginResponse // = 1
    case logoutRequest // = 2
    case logoutResponse // = 3
    case keepaliveRequest // = 4
    case keepaliveResponse // = 5
    case messageRequest // = 6
    case messageResponse // = 7
    case messageNotification // = 8

    init() {
        self = .loginRequest
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .loginRequest
        case 1: self = .loginResponse
        case 2: self = .logoutRequest
        case 3: self = .logoutResponse
        case 4: self = .keepaliveRequest
        case 5: self = .keepaliveResponse
        case 6: self = .messageRequest
        case 7: self = .messageResponse
        case 8: self = .messageNotification
        default: return nil
        }
    }

    var rawValue: Int {
        switch self {
        case .loginRequest: return 0
        case .loginResponse: return 1
        case .logoutRequest: return 2
        case .logoutResponse: return 3
        case .keepaliveRequest: return 4
        case .keepaliveResponse: return 5
        case .messageRequest: return 6
        case .messageResponse: return 7
        case .messageNotification: return 8
        }
    }
}

#if swift(>=4.2)

    extension HeadType: CaseIterable {
        // Support synthesized by the compiler.
    }

#endif // swift(>=4.2)

struct LoginRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String {
        get { return _userID ?? String() }
        set { _userID = newValue }
    }

    /// Returns true if `userID` has been explicitly set.
    var hasUserID: Bool { return self._userID != nil }
    /// Clears the value of `userID`. Subsequent reads from it will return its default value.
    mutating func clearUserID() { _userID = nil }

    var deviceID: String {
        get { return _deviceID ?? String() }
        set { _deviceID = newValue }
    }

    /// Returns true if `deviceID` has been explicitly set.
    var hasDeviceID: Bool { return self._deviceID != nil }
    /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
    mutating func clearDeviceID() { _deviceID = nil }

    var token: String {
        get { return _token ?? String() }
        set { _token = newValue }
    }

    /// Returns true if `token` has been explicitly set.
    var hasToken: Bool { return self._token != nil }
    /// Clears the value of `token`. Subsequent reads from it will return its default value.
    mutating func clearToken() { _token = nil }

    var platform: UInt32 {
        get { return _platform ?? 0 }
        set { _platform = newValue }
    }

    /// Returns true if `platform` has been explicitly set.
    var hasPlatform: Bool { return self._platform != nil }
    /// Clears the value of `platform`. Subsequent reads from it will return its default value.
    mutating func clearPlatform() { _platform = nil }

    var appVersion: String {
        get { return _appVersion ?? String() }
        set { _appVersion = newValue }
    }

    /// Returns true if `appVersion` has been explicitly set.
    var hasAppVersion: Bool { return self._appVersion != nil }
    /// Clears the value of `appVersion`. Subsequent reads from it will return its default value.
    mutating func clearAppVersion() { _appVersion = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _userID: String?
    fileprivate var _deviceID: String?
    fileprivate var _token: String?
    fileprivate var _platform: UInt32?
    fileprivate var _appVersion: String?
}

struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var result: Bool {
        get { return _result ?? false }
        set { _result = newValue }
    }

    /// Returns true if `result` has been explicitly set.
    var hasResult: Bool { return self._result != nil }
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    mutating func clearResult() { _result = nil }

    var code: UInt32 {
        get { return _code ?? 0 }
        set { _code = newValue }
    }

    /// Returns true if `code` has been explicitly set.
    var hasCode: Bool { return self._code != nil }
    /// Clears the value of `code`. Subsequent reads from it will return its default value.
    mutating func clearCode() { _code = nil }

    var info: String {
        get { return _info ?? String() }
        set { _info = newValue }
    }

    /// Returns true if `info` has been explicitly set.
    var hasInfo: Bool { return self._info != nil }
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    mutating func clearInfo() { _info = nil }

    var expose: UInt32 {
        get { return _expose ?? 0 }
        set { _expose = newValue }
    }

    /// Returns true if `expose` has been explicitly set.
    var hasExpose: Bool { return self._expose != nil }
    /// Clears the value of `expose`. Subsequent reads from it will return its default value.
    mutating func clearExpose() { _expose = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _result: Bool?
    fileprivate var _code: UInt32?
    fileprivate var _info: String?
    fileprivate var _expose: UInt32?
}

struct MessageRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: UInt32 {
        get { return _type ?? 0 }
        set { _type = newValue }
    }

    /// Returns true if `type` has been explicitly set.
    var hasType: Bool { return self._type != nil }
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() { _type = nil }

    var groupID: String {
        get { return _groupID ?? String() }
        set { _groupID = newValue }
    }

    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool { return self._groupID != nil }
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() { _groupID = nil }

    var msgType: UInt32 {
        get { return _msgType ?? 0 }
        set { _msgType = newValue }
    }

    /// Returns true if `msgType` has been explicitly set.
    var hasMsgType: Bool { return self._msgType != nil }
    /// Clears the value of `msgType`. Subsequent reads from it will return its default value.
    mutating func clearMsgType() { _msgType = nil }

    var fromID: String {
        get { return _fromID ?? String() }
        set { _fromID = newValue }
    }

    /// Returns true if `fromID` has been explicitly set.
    var hasFromID: Bool { return self._fromID != nil }
    /// Clears the value of `fromID`. Subsequent reads from it will return its default value.
    mutating func clearFromID() { _fromID = nil }

    var toID: String {
        get { return _toID ?? String() }
        set { _toID = newValue }
    }

    /// Returns true if `toID` has been explicitly set.
    var hasToID: Bool { return self._toID != nil }
    /// Clears the value of `toID`. Subsequent reads from it will return its default value.
    mutating func clearToID() { _toID = nil }

    var time: UInt64 {
        get { return _time ?? 0 }
        set { _time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { return self._time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _time = nil }

    var message: String {
        get { return _message ?? String() }
        set { _message = newValue }
    }

    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool { return self._message != nil }
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() { _message = nil }

    var secretKey: String {
        get { return _secretKey ?? String() }
        set { _secretKey = newValue }
    }

    /// Returns true if `secretKey` has been explicitly set.
    var hasSecretKey: Bool { return self._secretKey != nil }
    /// Clears the value of `secretKey`. Subsequent reads from it will return its default value.
    mutating func clearSecretKey() { _secretKey = nil }

    var selfSecretKey: String {
        get { return _selfSecretKey ?? String() }
        set { _selfSecretKey = newValue }
    }

    /// Returns true if `selfSecretKey` has been explicitly set.
    var hasSelfSecretKey: Bool { return self._selfSecretKey != nil }
    /// Clears the value of `selfSecretKey`. Subsequent reads from it will return its default value.
    mutating func clearSelfSecretKey() { _selfSecretKey = nil }

    var fromNick: String {
        get { return _fromNick ?? String() }
        set { _fromNick = newValue }
    }

    /// Returns true if `fromNick` has been explicitly set.
    var hasFromNick: Bool { return self._fromNick != nil }
    /// Clears the value of `fromNick`. Subsequent reads from it will return its default value.
    mutating func clearFromNick() { _fromNick = nil }

    var flag: UInt32 {
        get { return _flag ?? 0 }
        set { _flag = newValue }
    }

    /// Returns true if `flag` has been explicitly set.
    var hasFlag: Bool { return self._flag != nil }
    /// Clears the value of `flag`. Subsequent reads from it will return its default value.
    mutating func clearFlag() { _flag = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _type: UInt32?
    fileprivate var _groupID: String?
    fileprivate var _msgType: UInt32?
    fileprivate var _fromID: String?
    fileprivate var _toID: String?
    fileprivate var _time: UInt64?
    fileprivate var _message: String?
    fileprivate var _secretKey: String?
    fileprivate var _selfSecretKey: String?
    fileprivate var _fromNick: String?
    fileprivate var _flag: UInt32?
}

struct MessageHeartBeat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var seq: UInt32 {
        get { return _seq ?? 0 }
        set { _seq = newValue }
    }

    /// Returns true if `seq` has been explicitly set.
    var hasSeq: Bool { return self._seq != nil }
    /// Clears the value of `seq`. Subsequent reads from it will return its default value.
    mutating func clearSeq() { _seq = nil }

    var userID: String {
        get { return _userID ?? String() }
        set { _userID = newValue }
    }

    /// Returns true if `userID` has been explicitly set.
    var hasUserID: Bool { return self._userID != nil }
    /// Clears the value of `userID`. Subsequent reads from it will return its default value.
    mutating func clearUserID() { _userID = nil }

    var json: String {
        get { return _json ?? String() }
        set { _json = newValue }
    }

    /// Returns true if `json` has been explicitly set.
    var hasJson: Bool { return self._json != nil }
    /// Clears the value of `json`. Subsequent reads from it will return its default value.
    mutating func clearJson() { _json = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _seq: UInt32?
    fileprivate var _userID: String?
    fileprivate var _json: String?
}

struct MessageNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var noID: UInt64 {
        get { return _noID ?? 0 }
        set { _noID = newValue }
    }

    /// Returns true if `noID` has been explicitly set.
    var hasNoID: Bool { return self._noID != nil }
    /// Clears the value of `noID`. Subsequent reads from it will return its default value.
    mutating func clearNoID() { _noID = nil }

    var json: String {
        get { return _json ?? String() }
        set { _json = newValue }
    }

    /// Returns true if `json` has been explicitly set.
    var hasJson: Bool { return self._json != nil }
    /// Clears the value of `json`. Subsequent reads from it will return its default value.
    mutating func clearJson() { _json = nil }

    var timestamp: String {
        get { return _timestamp ?? String() }
        set { _timestamp = newValue }
    }

    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool { return self._timestamp != nil }
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() { _timestamp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _noID: UInt64?
    fileprivate var _json: String?
    fileprivate var _timestamp: String?
}

struct Message {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: HeadType {
        get { return _storage._type ?? .loginRequest }
        set { _uniqueStorage()._type = newValue }
    }

    /// Returns true if `type` has been explicitly set.
    var hasType: Bool { return _storage._type != nil }
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() { _uniqueStorage()._type = nil }

    var sequence: UInt64 {
        get { return _storage._sequence ?? 0 }
        set { _uniqueStorage()._sequence = newValue }
    }

    /// Returns true if `sequence` has been explicitly set.
    var hasSequence: Bool { return _storage._sequence != nil }
    /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
    mutating func clearSequence() { _uniqueStorage()._sequence = nil }

    var sessionID: String {
        get { return _storage._sessionID ?? String() }
        set { _uniqueStorage()._sessionID = newValue }
    }

    /// Returns true if `sessionID` has been explicitly set.
    var hasSessionID: Bool { return _storage._sessionID != nil }
    /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
    mutating func clearSessionID() { _uniqueStorage()._sessionID = nil }

    var loginRequest: LoginRequest {
        get { return _storage._loginRequest ?? LoginRequest() }
        set { _uniqueStorage()._loginRequest = newValue }
    }

    /// Returns true if `loginRequest` has been explicitly set.
    var hasLoginRequest: Bool { return _storage._loginRequest != nil }
    /// Clears the value of `loginRequest`. Subsequent reads from it will return its default value.
    mutating func clearLoginRequest() { _uniqueStorage()._loginRequest = nil }

    var response: Response {
        get { return _storage._response ?? Response() }
        set { _uniqueStorage()._response = newValue }
    }

    /// Returns true if `response` has been explicitly set.
    var hasResponse: Bool { return _storage._response != nil }
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    mutating func clearResponse() { _uniqueStorage()._response = nil }

    var messageRequest: MessageRequest {
        get { return _storage._messageRequest ?? MessageRequest() }
        set { _uniqueStorage()._messageRequest = newValue }
    }

    /// Returns true if `messageRequest` has been explicitly set.
    var hasMessageRequest: Bool { return _storage._messageRequest != nil }
    /// Clears the value of `messageRequest`. Subsequent reads from it will return its default value.
    mutating func clearMessageRequest() { _uniqueStorage()._messageRequest = nil }

    var heartBeat: MessageHeartBeat {
        get { return _storage._heartBeat ?? MessageHeartBeat() }
        set { _uniqueStorage()._heartBeat = newValue }
    }

    /// Returns true if `heartBeat` has been explicitly set.
    var hasHeartBeat: Bool { return _storage._heartBeat != nil }
    /// Clears the value of `heartBeat`. Subsequent reads from it will return its default value.
    mutating func clearHeartBeat() { _uniqueStorage()._heartBeat = nil }

    var notification: MessageNotification {
        get { return _storage._notification ?? MessageNotification() }
        set { _uniqueStorage()._notification = newValue }
    }

    /// Returns true if `notification` has been explicitly set.
    var hasNotification: Bool { return _storage._notification != nil }
    /// Clears the value of `notification`. Subsequent reads from it will return its default value.
    mutating func clearNotification() { _uniqueStorage()._notification = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HeadType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "LOGIN_REQUEST"),
        1: .same(proto: "LOGIN_RESPONSE"),
        2: .same(proto: "LOGOUT_REQUEST"),
        3: .same(proto: "LOGOUT_RESPONSE"),
        4: .same(proto: "KEEPALIVE_REQUEST"),
        5: .same(proto: "KEEPALIVE_RESPONSE"),
        6: .same(proto: "MESSAGE_REQUEST"),
        7: .same(proto: "MESSAGE_RESPONSE"),
        8: .same(proto: "MESSAGE_NOTIFICATION"),
    ]
}

extension LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "LoginRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "userId"),
        2: .same(proto: "deviceId"),
        3: .same(proto: "token"),
        4: .same(proto: "platform"),
        5: .same(proto: "appVersion"),
    ]

    public var isInitialized: Bool {
        if self._userID == nil { return false }
        if self._deviceID == nil { return false }
        if self._token == nil { return false }
        return true
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self._userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._deviceID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._token) }()
            case 4: try { try decoder.decodeSingularUInt32Field(value: &self._platform) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self._appVersion) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _userID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 1)
        }
        if let v = _deviceID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        }
        if let v = _token {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        }
        if let v = _platform {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
        }
        if let v = _appVersion {
            try visitor.visitSingularStringField(value: v, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: LoginRequest, rhs: LoginRequest) -> Bool {
        if lhs._userID != rhs._userID { return false }
        if lhs._deviceID != rhs._deviceID { return false }
        if lhs._token != rhs._token { return false }
        if lhs._platform != rhs._platform { return false }
        if lhs._appVersion != rhs._appVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Response"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "result"),
        2: .same(proto: "code"),
        3: .same(proto: "info"),
        4: .same(proto: "expose"),
    ]

    public var isInitialized: Bool {
        if self._result == nil { return false }
        if self._code == nil { return false }
        return true
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self._result) }()
            case 2: try { try decoder.decodeSingularUInt32Field(value: &self._code) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._info) }()
            case 4: try { try decoder.decodeSingularUInt32Field(value: &self._expose) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _result {
            try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
        }
        if let v = _code {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
        }
        if let v = _info {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        }
        if let v = _expose {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Response, rhs: Response) -> Bool {
        if lhs._result != rhs._result { return false }
        if lhs._code != rhs._code { return false }
        if lhs._info != rhs._info { return false }
        if lhs._expose != rhs._expose { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension MessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "MessageRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "groupId"),
        3: .same(proto: "msgType"),
        4: .same(proto: "fromId"),
        5: .same(proto: "toId"),
        6: .same(proto: "time"),
        7: .same(proto: "message"),
        8: .same(proto: "secretKey"),
        9: .same(proto: "selfSecretKey"),
        10: .same(proto: "fromNick"),
        11: .same(proto: "flag"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self._type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._groupID) }()
            case 3: try { try decoder.decodeSingularUInt32Field(value: &self._msgType) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self._fromID) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self._toID) }()
            case 6: try { try decoder.decodeSingularUInt64Field(value: &self._time) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self._message) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self._secretKey) }()
            case 9: try { try decoder.decodeSingularStringField(value: &self._selfSecretKey) }()
            case 10: try { try decoder.decodeSingularStringField(value: &self._fromNick) }()
            case 11: try { try decoder.decodeSingularUInt32Field(value: &self._flag) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _type {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
        }
        if let v = _groupID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        }
        if let v = _msgType {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
        }
        if let v = _fromID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        }
        if let v = _toID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 5)
        }
        if let v = _time {
            try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
        }
        if let v = _message {
            try visitor.visitSingularStringField(value: v, fieldNumber: 7)
        }
        if let v = _secretKey {
            try visitor.visitSingularStringField(value: v, fieldNumber: 8)
        }
        if let v = _selfSecretKey {
            try visitor.visitSingularStringField(value: v, fieldNumber: 9)
        }
        if let v = _fromNick {
            try visitor.visitSingularStringField(value: v, fieldNumber: 10)
        }
        if let v = _flag {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: MessageRequest, rhs: MessageRequest) -> Bool {
        if lhs._type != rhs._type { return false }
        if lhs._groupID != rhs._groupID { return false }
        if lhs._msgType != rhs._msgType { return false }
        if lhs._fromID != rhs._fromID { return false }
        if lhs._toID != rhs._toID { return false }
        if lhs._time != rhs._time { return false }
        if lhs._message != rhs._message { return false }
        if lhs._secretKey != rhs._secretKey { return false }
        if lhs._selfSecretKey != rhs._selfSecretKey { return false }
        if lhs._fromNick != rhs._fromNick { return false }
        if lhs._flag != rhs._flag { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension MessageHeartBeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "MessageHeartBeat"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "seq"),
        2: .same(proto: "userId"),
        3: .same(proto: "json"),
    ]

    public var isInitialized: Bool {
        if self._seq == nil { return false }
        if self._userID == nil { return false }
        if self._json == nil { return false }
        return true
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self._seq) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._userID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._json) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _seq {
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
        }
        if let v = _userID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        }
        if let v = _json {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: MessageHeartBeat, rhs: MessageHeartBeat) -> Bool {
        if lhs._seq != rhs._seq { return false }
        if lhs._userID != rhs._userID { return false }
        if lhs._json != rhs._json { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension MessageNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "MessageNotification"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "noId"),
        2: .same(proto: "json"),
        3: .same(proto: "timestamp"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self._noID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._json) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._timestamp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _noID {
            try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
        }
        if let v = _json {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        }
        if let v = _timestamp {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: MessageNotification, rhs: MessageNotification) -> Bool {
        if lhs._noID != rhs._noID { return false }
        if lhs._json != rhs._json { return false }
        if lhs._timestamp != rhs._timestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Message"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "sequence"),
        3: .same(proto: "sessionId"),
        4: .same(proto: "loginRequest"),
        5: .same(proto: "response"),
        6: .same(proto: "messageRequest"),
        7: .same(proto: "heartBeat"),
        8: .same(proto: "notification"),
    ]

    fileprivate class _StorageClass {
        var _type: HeadType?
        var _sequence: UInt64?
        var _sessionID: String?
        var _loginRequest: LoginRequest?
        var _response: Response?
        var _messageRequest: MessageRequest?
        var _heartBeat: MessageHeartBeat?
        var _notification: MessageNotification?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _type = source._type
            _sequence = source._sequence
            _sessionID = source._sessionID
            _loginRequest = source._loginRequest
            _response = source._response
            _messageRequest = source._messageRequest
            _heartBeat = source._heartBeat
            _notification = source._notification
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public var isInitialized: Bool {
        return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._loginRequest, !v.isInitialized { return false }
            if let v = _storage._response, !v.isInitialized { return false }
            if let v = _storage._heartBeat, !v.isInitialized { return false }
            return true
        }
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
                case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._sequence) }()
                case 3: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
                case 4: try { try decoder.decodeSingularMessageField(value: &_storage._loginRequest) }()
                case 5: try { try decoder.decodeSingularMessageField(value: &_storage._response) }()
                case 6: try { try decoder.decodeSingularMessageField(value: &_storage._messageRequest) }()
                case 7: try { try decoder.decodeSingularMessageField(value: &_storage._heartBeat) }()
                case 8: try { try decoder.decodeSingularMessageField(value: &_storage._notification) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if let v = _storage._type {
                try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
            }
            if let v = _storage._sequence {
                try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
            }
            if let v = _storage._sessionID {
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }
            if let v = _storage._loginRequest {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }
            if let v = _storage._response {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }
            if let v = _storage._messageRequest {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }
            if let v = _storage._heartBeat {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }
            if let v = _storage._notification {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Message, rhs: Message) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._type != rhs_storage._type { return false }
                if _storage._sequence != rhs_storage._sequence { return false }
                if _storage._sessionID != rhs_storage._sessionID { return false }
                if _storage._loginRequest != rhs_storage._loginRequest { return false }
                if _storage._response != rhs_storage._response { return false }
                if _storage._messageRequest != rhs_storage._messageRequest { return false }
                if _storage._heartBeat != rhs_storage._heartBeat { return false }
                if _storage._notification != rhs_storage._notification { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
